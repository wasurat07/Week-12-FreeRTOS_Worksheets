# บันทึกผลการทดลอง
## Lab1-single-vs-multi
### คำถามสำหรับวิเคราะห์
1. ความแตกต่างในการตอบสนองปุ่มระหว่างทั้งสองระบบคืออะไร?
- Single Task System: ตอบสนองปุ่ม ช้า เพราะงานหลักที่กินเวลานาน (Long-running Task) บล็อก ระบบทั้งหมด
- Multitasking System: ตอบสนองปุ่ม เร็ว เพราะมีการ แบ่งเวลา (Time Slicing) ทำให้สามารถสลับไปตอบสนองผู้ใช้ได้ทันที

2. ใน Single Task System งานไหนที่ทำให้การตอบสนองล่าช้า?
- งานที่ใช้ ทรัพยากร CPU สูง เป็นเวลานาน (CPU-intensive tasks) หรืองานที่ต้อง รอ I/O นาน จะทำให้ระบบไม่สามารถตอบสนองปุ่มได้ทันท่วงที
- สรุปคือ งานหลักที่รันอยู่ จะเป็นตัวบล็อกการตอบสนองของปุ่ม

3. ข้อดีของ Multitasking System ที่สังเกตได้คืออะไร?
- ตอบสนองดีขึ้น ต่อการกระทำของผู้ใช้
- สามารถ รันหลายกิจกรรมพร้อมกัน ได้อย่างมีประสิทธิภาพ
- ให้ประสบการณ์การใช้งานที่ ต่อเนื่องและราบรื่น

4. มีข้อเสียของ Multitasking System ที่สังเกตได้หรือไม่?
- เกิด ค่าใช้จ่าย ในการสลับบริบท (Context Switching overhead)
- เสี่ยงต่อการ แย่งชิงทรัพยากร และปัญหาการจัดการความสำคัญ (priority)

## Lab 2: Time-Sharing Implementation
### คำถามสำหรับวิเคราะห์
1. Time slice ขนาดไหนให้ประสิทธิภาพดีที่สุด? เพราะอะไร?
- ขนาดที่ เหมาะสม (โดยทั่วไป 10-100 ms)
- เพราะ เป็นจุดที่ สมดุล กันระหว่างการตอบสนองที่รวดเร็ว (interactive feel) และการลดค่าใช้จ่ายในการสลับบริบท

2. ปัญหาอะไรที่เกิดขึ้นเมื่อ time slice สั้นเกินไป?
- เกิดการ สลับงานบ่อยเกินไป ทำให้ CPU ต้องใช้เวลาส่วนใหญ่ไปกับ Context Switching overhead ส่งผลให้ประสิทธิภาพการประมวลผลจริงลดลงอย่างมาก

3. ปัญหาอะไรที่เกิดขึ้นเมื่อ time slice ยาวเกินไป?
- งานที่รันอยู่จะ ครอบครอง CPU นาน ทำให้งานอื่นต้องรอคอยเป็นเวลานาน ส่งผลให้ การตอบสนองของผู้ใช้แย่ลง

4. Context switching overhead คิดเป็นกี่เปอร์เซ็นต์ของเวลาทั้งหมด?
- ขึ้นอยู่กับสถาปัตยกรรม แต่โดยทั่วไปอยู่ที่ประมาณ 1–5% หาก Time slice สั้นเกินไป ค่านี้จะ เพิ่มขึ้นอย่างมีนัยสำคัญ (อาจเกิน 10%)

5. งานไหนที่ได้รับผลกระทบมากที่สุดจากการ time-sharing?
-  งานที่ต้องใช้ CPU ต่อเนื่อง (CPU-bound tasks) เพราะงานจะถูกขัดจังหวะบ่อยครั้งก่อนที่จะเสร็จสมบูรณ์ และต้องรอรอบต่อไปเสมอ

## Lab 3: Cooperative vs Preemptive Comparison
### คำถามสำหรับวิเคราะห์
1. ระบบไหนมีเวลาตอบสนองดีกว่า? เพราะอะไร?
- Preemptive ดีกว่า เพราะงานที่มีลำดับความสำคัญสูงสามารถ แทรกแซง เพื่อเข้าใช้ CPU ได้ทันที ทำให้มีความหน่วง (latency) ที่ต่ำกว่า

2. ข้อดีของ Cooperative Multitasking คืออะไร?
- มี Overhead ต่ำ เพราะการสลับบริบททำเฉพาะจุดที่กำหนดไว้
- ง่ายต่อการควบคุม และดีบัก เนื่องจากลำดับการทำงานเป็นเส้นตรง

3. ข้อเสียของ Cooperative Multitasking คืออะไร?
- ความหน่วงสูง หากงานใดงานหนึ่งไม่ยอมปล่อย CPU (No yielding) ทำให้งานอื่นและเหตุฉุกเฉินต้องรอ
- พึ่งพาความน่าเชื่อถือ ของโค้ดแต่ละส่วนในการปล่อย CPU อย่างสม่ำเสมอ

4. ในสถานการณ์ใดที่ Cooperative จะดีกว่า Preemptive?
- ใน ระบบขนาดเล็ก ที่ต้องการ Overhead ต่ำมาก และนักพัฒนาสามารถรับประกันได้ว่าทุกงานจะมีการ หยุดพัก (yield) บ่อยพอ

5. เหตุใด Preemptive จึงเหมาะสำหรับ Real-time systems?
- สามารถ รับประกัน การตอบสนองตามลำดับความสำคัญได้จริง (Priority-based scheduling)
- ช่วยให้งานสำคัญสูงสามารถ เข้าถึงทรัพยากรได้ภายในขอบเขตเวลาที่กำหนด (bounded latency) ป้องกันไม่ให้งานสำคัญต่ำมาบล็อกระบบ

