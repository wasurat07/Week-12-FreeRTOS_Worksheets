# บันทึกผลการทดลอง
## Lab 1: ESP-IDF Setup และโปรเจกต์แรก
### คำถามทบทวน
1. ไฟล์ใดบ้างที่จำเป็นสำหรับโปรเจกต์ ESP-IDF ขั้นต่ำ?
- CMakeLists.txt (ในโฟลเดอร์ราก): ใช้เพื่อกำหนดชื่อโปรเจกต์ด้วยคำสั่ง project(<ชื่อโปรเจกต์>)
- main/CMakeLists.txt: ใช้เพื่อลงทะเบียนคอมโพเนนต์หลัก (main) และระบุไฟล์ต้นฉบับภาษา C (.c)
- ไฟล์ต้นฉบับ C (เช่น main/app_main.c): ไฟล์ที่มีฟังก์ชัน app_main() ซึ่งเป็นจุดเริ่มต้นการทำงานของแอปพลิเคชัน
- sdkconfig: ไฟล์การตั้งค่าที่ถูก สร้างขึ้นโดยอัตโนมัติ หลังจากการตั้งค่าหรือคอมไพล์ครั้งแรก ซึ่งจำเป็นต่อการสร้างไบนารีที่ถูกต้อง
```
your_project/
├─ CMakeLists.txt # ระดับรากโปรเจกต์
├─ main/
│ ├─ CMakeLists.txt # ลงทะเบียนคอมโพเนนต์/ไฟล์ .c
│ └─ hello_esp32.c # มีฟังก์ชัน app_main()
└─ sdkconfig # สร้างอัตโนมัติหลัง build ครั้งแรก
```
2. ความแตกต่างระหว่าง hello_esp32.bin และ hello_esp32.elf คืออะไร?
- .elf คือไฟล์สำหรับดีบัก มีสัญลักษณ์ ตารางที่อยู่ และข้อมูลที่จำเป็นสำหรับเครื่องมือดีบักอยู่ครบ ใช้กับ gdb, addr2line, size
- .bin คือไบนารีที่พร้อมแฟลช ลงในหน่วยความจำของชิป สกัดออกมาจาก .elf โดยมีการ ตัดข้อมูลดีบักออก เพื่อให้มีขนาดเล็กลง

3. คำสั่ง idf.py set-target ทำอะไร?
- ทำหน้าที่ กำหนดสถาปัตยกรรมของชิปเป้าหมาย (เช่น ESP32, ESP32-S3)
- คำสั่งนี้จะปรับค่าตัวแปรสิ่งแวดล้อม IDF_TARGET และปรับ sdkconfig ให้สอดคล้องกับฮาร์ดแวร์ที่เลือก และบังคับให้ CMake เลือกใช้ชุดเครื่องมือ (toolchain) ที่ถูกต้อง สำหรับการคอมไพล์

4. โฟลเดอร์ build/ มีไฟล์อะไรบ้าง?
- เอาต์พุตหลักของแอป: hello_esp32.elf, hello_esp32.bin, hello_esp32.map
- โฟลเดอร์ย่อยสำคัญ:
  - bootloader/ (เช่น bootloader.elf/.bin)
  - partition_table/ (เช่น partition-table.bin/.csv)
  - esp-idf/ (ออบเจ็กต์ของแต่ละคอมโพเนนต์)
  - ไฟล์อำนวยความสะดวก: flasher_args.json, flash_project_args, config/, sdkconfig.h, compile_commands.json
  - ไฟล์ CMake: CMakeCache.txt, CMakeFiles/, และบางโปรเจกต์จะมีโฟลเดอร์ ld/ สำหรับลิงเกอร์สคริปต์ที่สร้างขึ้น
  - สรุป: build/ คือพื้นที่กลางของ CMake ที่เก็บไฟล์ทั้งหมดที่จำเป็นต่อการแฟลชและดีบัก

5. การใช้ vTaskDelay() แทน delay() มีความสำคัญอย่างไร?
- vTaskDelay() เป็นฟังก์ชันที่ ให้ Task เข้าสู่สถานะพัก (Blocked) ชั่วคราว และ คืน CPU ให้กับ FreeRTOS Scheduler เพื่อให้ Task อื่นสามารถรันได้ ซึ่งช่วย ประหยัดพลังงาน และไม่เกิด Busy-wait
- เป็นการหน่วงเวลาที่อ้างอิงจาก Tick ของ FreeRTOS ซึ่งทำให้การทำงานมีความคาดเดาได้ในสภาพแวดล้อม Multitasking (ใช้ pdMS_TO_TICKS(ms) เพื่อแปลงเวลา)

## Lab 2: Hello World และ Serial Communication
## คำถามทบทวน
1. ความแตกต่างระหว่าง `printf()` และ `ESP_LOGI()` คืออะไร?
- printf(): เป็นฟังก์ชันมาตรฐาน C ที่ แสดงผลทันที โดยไม่มีการจัดรูปแบบข้อมูลเชิงระบบ
- ESP_LOGI(): เป็นส่วนหนึ่งของ ระบบ Logging ของ ESP-IDF ที่มีความสามารถในการ กำหนดระดับความสำคัญ (เช่น Info, Error, Debug), มี Tag (ชื่อคอมโพเนนต์), และสามารถแสดง Timestamp และควบคุมการแสดงผลผ่าน sdkconfig ได้อย่างยืดหยุ่น

2. Log level ไหนที่จะแสดงใน default configuration?
- Log Level เริ่มต้นที่ถูกกำหนดไว้คือ INFO level
- ดังนั้น Log ที่มีระดับ Error (E), Warning (W), และ Info (I) จะถูกแสดงผล ส่วน Log ระดับ Debug (D) และ Verbose (V) จะถูกกรองออกไป

3. การใช้ `ESP_ERROR_CHECK()` มีประโยชน์อย่างไร?
- เป็นกลไกในการ ตรวจสอบค่าคืนกลับ ของฟังก์ชันที่ส่งคืนค่า esp_err_t
- ถ้าฟังก์ชัน ล้มเหลว (เกิด Error) มันจะ พิมพ์รายละเอียดข้อผิดพลาด (รวมถึงชื่อไฟล์และบรรทัด) โดยอัตโนมัติ และ หยุดการทำงาน ของโปรแกรม (abort) ซึ่งช่วยลดความซ้ำซ้อนในการเขียนโค้ดเช็กเงื่อนไข

4. คำสั่งใดในการออกจาก Monitor mode?
- คำสั่งสำหรับออกจาก idf.py monitor คือการกด Ctrl + ]

5. การตั้งค่า Log level สำหรับ tag เฉพาะทำอย่างไร?
- ใช้ฟังก์ชัน esp_log_level_set("ชื่อ TAG", ESP_LOG_ระดับที่ต้องการ)
- วิธีนี้ทำให้สามารถ เปิด/ปิด หรือ ปรับความละเอียด ของ Log สำหรับคอมโพเนนต์หรือโมดูลที่สนใจเท่านั้น โดยที่คอมโพเนนต์อื่นยังคงใช้ Log Level ตามค่าเริ่มต้นของระบบ

## Lab 3: สร้าง Task แรกด้วย FreeRTOS
### คำถามทบทวน
1. เหตุใด Task function ต้องมี infinite loop?
- เนื่องจาก Task ถูกจัดการโดย FreeRTOS Scheduler หาก Task จบการทำงาน (return ออกจากฟังก์ชัน) ระบบจะถือว่า Task นั้นสิ้นสุด และหน่วยความจำ Stack ของ Task นั้นอาจถูกนำไปใช้ใหม่
- ดังนั้น Task ส่วนใหญ่จึงจำเป็นต้องมี while (1) เพื่อ วนลูปทำงาน และ อยู่ในการควบคุม ของ Scheduler ตลอดเวลา

2. ความหมายของ stack size ใน xTaskCreate() คืออะไร?
- คือ ขนาดของหน่วยความจำ Stack (หน่วยเป็น bytes) ที่ถูกจัดสรรให้กับ Task นั้น
- Stack ใช้สำหรับเก็บ ตัวแปรท้องถิ่น (local variables), ข้อมูล Call Stack ของฟังก์ชัน, และ Context ของ Task
- หากขนาดเล็กเกินไปจะเกิด Stack Overflow

3. ความแตกต่างระหว่าง vTaskDelay() และ vTaskDelayUntil()?
- vTaskDelay(): เป็นการหน่วงเวลาแบบ สัมพัทธ์ (Relative Delay) นับจากเวลาที่เรียกใช้ฟังก์ชัน
- vTaskDelayUntil(): เป็นการหน่วงเวลาแบบ แน่นอน (Absolute/Periodic Delay) โดยจะคำนวณเวลาพักจาก จุดเริ่มต้นครั้งก่อนหน้า ทำให้สามารถรักษา คาบเวลาที่คงที่ (Fixed Period) ของการทำงานในลูปได้แม่นยำกว่า

4. การใช้ vTaskDelete(NULL) vs vTaskDelete(handle) ต่างกันอย่างไร?
- vTaskDelete(NULL): Task นั้น ลบตัวเอง (ใช้เมื่อ Task ทำงานเสร็จสิ้นและต้องการยุติ)
- vTaskDelete(handle): Task ที่เรียกใช้ฟังก์ชัน ลบ Task อื่น โดยอ้างอิงจาก Task Handle ที่ระบุ

5. Priority 0 กับ Priority 24 อันไหนสูงกว่า?
- Task ที่มี Priority 24 สูงกว่า Task ที่มี Priority 0
- ใน FreeRTOS ค่า Priority ยิ่งมากยิ่งสูง และ Scheduler จะเลือกให้ Task ที่มี Priority สูงสุดรันก่อนเสมอ
